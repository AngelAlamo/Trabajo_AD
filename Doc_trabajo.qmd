---
title: "Análisis del Dataset spotify-2023"
author: 
  - name: Ángel Álamo
  - name: Juanjo Doblas
  - name: Óscar Vanrell 
format: html
editor: visual
execute:
  echo: false
---

## Introducción

En este documento se presentará un estudio detallado del Dataset Spotify 2023, obtenido de la página web Kaggle y que podéis encontrar en este [enlace](https://www.kaggle.com/datasets/nelgiriyewithana/top-spotify-songs-2023/). La base de datos original ya es ordenada (o _tidy_), por lo que no realizaremos ninguna modificación

Respecto al estudio, estará enfocado en determinar cuáles son las características comunes entre las canciones más reproducidas, para ello, intentaremos responder las siguientes preguntas para obtener conclusiones:

1. Analisis de la popularidad de la canción según la estación del año en que salió la canción.

2. Qué características son comunes entre las 100 canciones más reproducidas.

3. Que artista tiene mas canciones en listas de Spotify

4. Top canciones/artistas con mayores reproducciones en las plataformas

5. Top 3 artistas con más canciones en el dataset (y porcentajes) y analizar sus canciones `{r} Yo `

6. ¿Son igual de famosas las canciones en distintas plataformas?. Correlacion entre listas y reproducciones de Spotify

7. Canciones más famosas por décadas y mirar si cambian las caracteristicas comunes  `{r} Yo `


```{r}
# 3. ¿Son igual de famosas las canciones en distintas plataformas?
# 9. Diferenciar entre solo o colaboracion, mode 
```


Una vez explicado el objetivo, mostremos los datos que contiene el Dataset.

Primero carguemos todas las librerías que usaremos.

```{r libreria, include = FALSE}
library(tidyverse)
library(patchwork)
library(ggcorrplot)
library(psych)
library(patchwork)
library(MVA)
library(lessR)
```

Ahora mostremos un pequeño resumen del conjunto de datos, además de nuestras modificaciones:


```{r dataset, warning = FALSE}
spotify = read_csv(file = "spotify-2023.csv", show_col_types = FALSE)

# Cambiamos el tipo de los valores

spotify2 <- spotify %>% 
  mutate(streams = as.integer(streams), 
         released_year = as.ordered(released_year),
         released_month = as.ordered(released_month),
         released_day = as.ordered(released_day)) %>%
         #artist_count = as.ordered(artist_count)
  mutate(across(where(is.character), as.factor)) %>% # chr a factor


  # Creamos y añadimos la variable estación de lanzamiento y la posicionamos antes de mes de lanzamiento
  mutate("released_season" = case_when(
      released_month %in% c(12, 1, 2) ~ "winter",
      released_month %in% 3:5 ~ "spring",
      released_month %in% 6:8 ~ "summer",
      released_month %in% 9:11 ~ "autumn",
      NA ~ NA)) %>% 
  
  
  mutate("collaboration" = case_when(
    artist_count == 1 ~ "solo",
    artist_count %in% 2:10 ~ "collaboration", 
    NA ~ NA)) %>%
  
  
  
  # Creamos y añadimos la variable reproducciones por artista y la posicionamos antes de el dia de lanzamiento
  group_by(`artist(s)_name`) %>%
  #mutate("songs_per_artist" = n()) %>% 
  mutate("artist_streams" = sum(streams)) %>%
  ungroup() %>%
  #relocate(songs_per_artist, .before = released_year )

  # Eliminamos ciertas variables
  select(!contains("charts")) %>% 
  
  # Recolocamos las variables
  relocate(streams, .after = artist_count) %>% 
  relocate(released_day, .before = released_year) %>% 
  relocate(released_month, .before = released_year) %>% 
  relocate(`artist(s)_name`, .before = track_name) %>%
  relocate(released_season, .before = released_month) %>%
  relocate(artist_streams, .before = released_day) %>%
  relocate(collaboration, .before = streams)




spotify2 %>% 
  glimpse
```

## Descripción de las variables

Realicemos una descripción de cada variable:


-   *artist(s)_name*: variable cualitativa que muestra el nombre del artista (o artistas) de la canción.

```{r head artist name}
head(spotify2$`artist(s)_name`,5)
```


-   *track_name*: variable cualitativa que muestra el nombre de la canción. Mostramos las 5 primeras canciones presentes:

```{r head track name}
head(spotify2$track_name,5)
```

-   *artist_count*: variable cualitativa que mide el número de artistas que contribuyen a la canción.

```{r summary artist count}
summary(spotify2$artist_count)
```

-   *collaboration*: variable cualitativa creada por nosotros que divide las canciones en dos grupos dependiendo de si han sido creadas por el propio artista o si es una colaboración de diferentes artistas:

```{r}
head(spotify2$collaboration,5)
```



-   *streams*: variable cuantitativa que representa el número de reproducciones en Spotify

```{r summary streams}
summary(spotify2$streams)
```
-   *artist_streams*:  variable cuantitativa creada por nosotros que representa el número de reproducciones totales por artista en Spotify.

```{r}
head(spotify2$artist_streams,5)
```

-   *released_day*: variable cualitativa ordinal que representa el día en el que se lanzó.

```{r summary released day}
summary(spotify2$released_day)
```
-   *released_season*: variable cualitativa creada por nosotros que representa le estación del año en la que se lanzó la canción:

```{r}
head(spotify2$released_season,5)
```

-   *released_month*: variable cualitativa ordinal que representa el mes en el que se lanzó.

```{r summary released month}
summary(spotify2$released_month)
```


-   *released_year*: variable cualitativa ordinal que representa el año en el que se lanzó.

```{r summary released year}
summary(spotify2$released_year)
```
-   *in_spotify_playlists*: variable cuantitativa que mide el número de listas de reproducción de Spotify en las que está incluida la canción.

```{r summary spotify playlists}
summary(spotify2$in_spotify_playlists)
```


-   *in_apple_playlists*: variable cuantitativa que mide el número de listas de reproducción de Apple Music en las que está incluida la canción.

```{r summary apple playlists}
summary(spotify2$in_apple_playlists)
```


-   *in_deezer_playlists*: variable cuantitativa que mide el número de listas de reproducción de Deezer en las que está incluida la canción.

```{r summary deezer playlists}
summary(spotify2$in_deezer_playlists)
```

-   *bpm*: variable cuantitativa que mide el número de beats por minuto (bpm) de la canción.

```{r summary bpm}
summary(spotify2$bpm)
```


-   *key*: variable cualitativa que expresa la tonalidad de la canción.

```{r summary key}
summary(spotify2$key)
```


-   *mode*: variable cualitativa que representa la escala de la canción

```{r summary mode}
summary(spotify2$mode)
```


-   *danceability_%*: variable cuantitativa que indica en porcentaje qué tan adecuada es la canción para bailar.

```{r summary danceability}
summary(spotify2$`danceability_%`)
```


-   *valence_%*: variable cuantitativa que indica en porcentaje la positividad del contenido musical de la canción.

```{r summary valence}
summary(spotify2$`valence_%`)
```


-   *energy_%*: variable cuantitativa que indica en porcentaje el nivel de energía percibido de la canción.

```{r summary energy}
summary(spotify2$`energy_%`)
```


-   *acousticness_%*: variable cuantitativa que indica en porcentaje la cantidad de sonido acústico en la canción.

```{r summary acousticness}
summary(spotify2$`acousticness_%`)
```


-   *instrumentalness_%*: variable cuantitativa que indica en porcentaje la cantidad de contenido instrumental en la canción.

```{r summary instrumentalness}
summary(spotify2$`instrumentalness_%`)
```


-   *liveness_%*: variable cuantitativa que indica en porcentaje la presencia de elementos de actuación en directo.

```{r summary liveness}
summary(spotify2$`liveness_%`)
```


-   *speechiness_%*: variable cuantitativa que indica en porcentaje la cantidad de palabras habladas en la canción.

```{r summary speechiness}
summary(spotify2$`speechiness_%`)
```

Una vez vistos el pequeño resumen del dataset y las descripciones de cada variable, procedamos a responder las preguntas que nos hemos planteado.

## Popularidad según estación del año.

Realizaremos un boxplot, añadiendo la media, para visualizar la variable *streams* agrupando los datos por la estación del año cuando se lanzaron las canciones. Seguiremos el siguiente criterio:
-   Invierno: meses 12, 1 y 2
-   Primavera: meses 3, 4 y 5
-   Verano: meses 6, 7 y 8
-   Otoño: meses 9, 10 y 11

```{r streams segun estacion(1), fig.height=5, fig.width=8}

# Añadimos la variable estación de lanzamiento y la posicionamos antes de mes de lanzamiento
spotify2 <- spotify2 %>%
  mutate("released_season" = case_when(
    released_month %in% c(12, 1, 2) ~ "winter",
    released_month %in% 3:5 ~ "spring",
    released_month %in% 6:8 ~ "summer",
    released_month %in% 9:11 ~ "autumn",
    NA ~ NA)) %>% 
  relocate(released_season, .before = released_month)

colores_clase = c("brown", "green", "yellow", "blue")

p_1 = spotify2 %>% 
  drop_na(released_season, streams) %>% 
  group_by(released_season) %>% 
  ggplot() + 
  geom_boxplot(aes(x = released_season, y = streams, color = released_season)) +
  stat_summary(aes(x = released_season, y = streams), fun = mean, geom = "point", shape = 19, 
               size = 1, color = "black") +
  labs(x = "Estación de lanzamiento", y = "Reproducciones en Spotify") +
  theme_bw() + 
  guides(fill = guide_legend(title = "Estaciones del año")) +
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold")) + 
  scale_color_manual(values = colores_clase)

p_1


#theme(axis.text = element_text(angle = ...))

```



```{r  streams segun estacion(2), fig.width = 10, warning = FALSE}
colores_degradados <- colorRampPalette(c("cyan3", "purple"))(length(unique(spotify2$released_month)))

p_2 = spotify2 %>%
  ggplot() +
  geom_point(aes(x = released_day, y = streams, color = released_month), na.rm = TRUE) +
  facet_grid(.~released_season) +
  labs(x = "Día del més", y = "Streams") +
  guides(fill = guide_legend(title = "Season")) +
  theme_bw() +
  theme(axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold"))

  #scale_color_manual(values = colores_degradados)


p_1 +
p_2

```


```{r}

# Boxplots por mes agrupados por estación

spotify2 %>% 
  drop_na(released_season, streams) %>% 
  group_by(released_season) %>% 
  ggplot() + 
  geom_boxplot(aes(x = released_season, y = streams, color = released_month)) +
  stat_summary(aes(x = released_season, y = streams), fun = mean, geom = "point", shape = 19, 
               size = 1, color = "black") +
  labs(x = "Estación de lanzamiento", y = "Reproducciones en Spotify") +
  theme_bw() + 
  guides(fill = guide_legend(title = "Estaciones del año")) +
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold"))
```










Podemos ver que las cajas mantienen rangos muy similares y que las canciones exitosas son valores atípicos. Una posible interpretación de este gráfico es que las canciones exitosas no dependen (únicamente?) de la estación del año en que se lancen.

### Matriz de dispersión

```{r matriz de dispersion, fig.height=20, fig.width=20}
#spotify2 %>%
 # select(where(is.numeric)) %>%
  #na.omit() %>% 
  #pairs(pch = 18)
```

### Matriz de covarianzas

```{r matriz de covarianzas, fig.height=10, fig.width=10}
#spotify2 %>%
 # select(where(is.numeric)) %>%
  #na.omit(.) %>% 
  #cor(.) %>% 
  #ggcorrplot(., hc.order = TRUE,
   #     type = "lower",
    #    colors = c("blue",
     #               "white", "red"))
```







# Estudio caracteristicas de las canciones:


Para resolver la cuestión de qué características comunes tienen nuestro conjunto de canciones más exitosas de 2023 vamos a realizar un gráfico de correlaciones entre estas junto con su número de reproducciones y así ver qué variables estan relacionadas, si es que existe relación entre alguna de ellas:



```{r correlación características, fig.width = 10, fig.height = 6}
spotify2 %>%
  select(streams,bpm, 17:23) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(.,
       cex = 0.5
       )
```


Como podemos observar la mayor parte de pares de variables no presentan correlación, además de que las distintas características de una canción apenas tienen correlación con el número de reproducciones de esta, que era el objetivo de esta pregunta. Aún asi veamos los siguientes gráficos de los pares de variables más correlacionados `energy_%`~`acousticness_%`y `danceability_%`~`valence_%`


```{r gráfico correl energia y acustica, fig.width = 10, fig.height = 6}
g_1 = spotify2 %>%
  ggplot(aes(x=`energy_%`,y=`acousticness_%`)) +
  geom_point(size = 2,  na.rm = TRUE,col = c("red", "blue")[as.integer(spotify2$mode)]) +

  geom_smooth(method = "lm",col="pink",lwd=1, alpha = 0.2) + 
  theme_bw()

#+ 
  #scale_y_continuous(limits = c(0,600))
```

`r # diferenciar entre mode major o minor??`

```{r gráfico correl energia y acustica(2), fig.width = 10}

a1 <-spotify2 %>%
  select(`energy_%`,`acousticness_%`)%>%
  na.omit %>% as.matrix()



g_11 = bvbox(a1,xlab = "energia", 
           ylab = "acustica",
      pch = 19, cex = 1.25, ,col = c("red", "blue")[as.integer(spotify2$mode)])
g_1 + g_11
```


```{r gráfico correl bailable y positividad, fig.width = 10, fig.height = 6}
spotify2 %>%
  ggplot(aes(x=`danceability_%`,y=`valence_%`)) +
  geom_point(size = 2,  na.rm = TRUE) + 
  geom_smooth(method = "lm",col="pink",lwd=1, alpha = 0.2) + 
  theme_bw() #+ 
  #scale_y_continuous(limits = c(0,600))
```

```{r gráfico correl bailable y positividad(2), fig.width = 10, fig.height = 6}
a1 <-spotify2 %>%
  select(`danceability_%`,`valence_%`)%>%
  na.omit %>% as.matrix()



g<- bvbox(a1,xlab = "bailable", 
           ylab = "positividad",
      pch = 19, cex = 1.25, col = "red")

```
Así, vemos que cuando una canción es mas energica, menos nivel acustico presenta, mientras que cuanto más positiva es la canción, más buena es para bailar.

Como los resultados generales del estudio de la correlación no nos es muy satisfactorio, vamos a reducir el tamaño de las canciones a las 100 más escuchadas y volveremos a estudiar sus características.




```{r, fig.width = 10, fig.height = 10}
#a<-spotify2 %>%
 # select(bpm,mode, 18:24) %>%
  #na.omit(.)
#library(GGally)
#ggpairs(a)
```








#Top 100 canciones y sus caracteristicas:

Empecemos identificando cuales son esas canciones más escuchadas asi como los artistas con mas reproducciones.


Veamos cuales son las 10 canciones mas escuchadas:
```{r tabla 10 mas esuchadas}

a10 <- spotify2 %>%
  arrange(desc(streams)) %>%
  slice_head( n = 10 )
head(a10)
```

```{r gráfico top 10 canciones, fig.width = 12, fig.height = 6}

colores_degradados2 <- rainbow(length(unique(a10$`artist(s)_name`)),start = .7, end = 1)
a10  %>%
  ggplot() + 
  geom_col(aes(x = reorder(track_name, desc(streams )) , y = streams, fill = `artist(s)_name`)) +
  scale_fill_manual(values = colores_degradados2,breaks = a10$`artist(s)_name`) +
  
  labs(title = "Top 10 canciones mas reproducidas en Spotify",x = "Canción", y = "Reproducciones ") +
  theme_bw() + 

  theme(axis.text = element_text(face = "bold",angle = 25, vjust = 0.5, hjust = 1),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold"))



```

```{r tabla top 10 cantantes}


b10 <- spotify2 %>%
  arrange(desc(artist_streams)) %>%
  distinct(`artist(s)_name`, .keep_all = TRUE) %>% #elimina las filas duplicadas en funcion de la columna artist_name
  slice_head( n = 10 )
head(b10)
```

```{r gráfico top 10 cantantes, fig.width = 12, fig.height = 6}

colores_degradados3 <- colorRampPalette(c("cyan3", "yellow2"))(length(unique(b10$track_name)))




b10  %>%
  
  ggplot() + 
  geom_col(aes(x = reorder(`artist(s)_name`, desc(artist_streams)) , y = artist_streams, fill = `artist(s)_name`)) +

  scale_fill_manual(values = colores_degradados3,breaks = b10$`artist(s)_name`) +
  
  labs(title = "Top 10 artistas con mas reproducciones en Spotify",x = "Artista", y = "Reproducciones ") +
  theme_bw() + 
  #guides(fill = guide_legend(title = "Artista")) +
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold"))



```



Volvemos a hacer un estudio de las correlaciones entre las distintas caracteristicas de las canciones como el hecho anteriormente pero ahora con las 100 canciones más escuchadas:


```{r correlacion del top100 ,fig.width = 10, fig.height = 6}

a100 <- spotify2 %>%
  slice_max(streams, n = 100)

a100 %>%
  select(streams,bpm, 17:23) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(.,
       cex = 0.5
       )

```



Podemos observar que ahora tenemos más variables que presentan mayor correlación con respecto al gráfico anterior, y como vemos, los pares de variables que presentan mayor correlación siguen siendo los mismos: `energy_%`~`acousticness_%`y `danceability_%`~`valence_%`. Sin embargo nos quedamos otra vez con las ganas de ver alguna característica que muestre relación con tener más reproducciones.




```{r grafico colaboraciones}

PieChart(collaboration, data = spotify2,
         fill = c("#BF3EFF","#87CEFA"),
         main = NULL)


```

# Estuido por plataformas:

```{r correlacion por plataformas, fig.width = 15, fig.height = 8}
spotify2 %>%
  select(streams, 11:13) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(.,
       cex = 1 , main = "Correlación Entre Plataformas"
       )
```
