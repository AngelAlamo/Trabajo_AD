---
title: "Análisis del Dataset spotify-2023"
author: 
  - name: Ángel Álamo
  - name: Juanjo Doblas
  - name: Óscar Vanrell 
format: html
editor: visual
execute:
  echo: false
  message: false
---

## Introducción

En este documento se presentará un estudio detallado del Dataset Spotify 2023, obtenido de la página web Kaggle y que podéis encontrar en este [enlace](https://www.kaggle.com/datasets/nelgiriyewithana/top-spotify-songs-2023/). La base de datos original ya es ordenada (o *tidy*). Las modificaciones que haremos al dataset original son la eliminación de ciertas variables que no son de interés en nuestro estudio y añadir algunas variables, calculadas a partir de otras, que nos ayudarán a realizar el estudio.

Respecto al estudio, estará enfocado en determinar cuáles son los factores comunes entre las canciones más reproducidas, para ello, intentaremos obtener información de las canciones del dataset a partir de los siguientes puntos:

1.  Características comunes entre las canciones.

    -   Considerando las 100 canciones más reproducidas.

2.  Analisis de las reproducciones de la canción según la estación del año.

3.  Top 5 artistas con más canciones en el dataset y comparación de las propiedades

4.  Estudio de las canciones según la época y características.

5.  ¿Son igual de famosas las canciones en distintas plataformas?. Correlaciones.

```{r librerias, include = FALSE}
library(tidyverse)
library(ggplot2)
library(patchwork)
library(ggcorrplot)
library(psych)
library(patchwork)
library(MVA)
library(lessR)
library(GGally)
library(ggradar)
library(ggpubr)
library(corrplot)
```

## Dataset

Una vez explicado el objetivo, presentamos el Dataset, mostramos un pequeño resumen del conjunto de datos, además de nuestras modificaciones respecto al tipo de variable y algunas variables nuevas:

```{r dataset, warning = FALSE}
spotify = read_csv(file = "spotify-2023.csv", show_col_types = FALSE)



breaks_bpm = c("60", "100", "120", "210")



# Cambiamos el tipo de los valores
spotify2 <- spotify %>% 
  mutate(streams = as.numeric(streams),
         released_month = as.ordered(released_month),
         released_day = as.ordered(released_day),
         key = factor(key, levels = c("C", "C#", "D", "D#", "E", "F", "G", "G#", "A", "A#", "B"))) %>%
  mutate(across(where(is.character), as.factor)) %>% # chr a factor
  mutate(artist_count = as.factor(artist_count)) %>% 
  
  # Creamos la variable colaboración
  mutate("collaboration" = case_when(
    artist_count == 1 ~ "solo",
    artist_count %in% 2:10 ~ "collaboration", 
    NA ~ NA)) %>%
  
  # Creamos y añadimos la variable reproducciones por artista y la posicionamos antes de el dia de lanzamiento
  group_by(`artist(s)_name`) %>%
  #mutate("songs_per_artist" = n()) %>% 
  mutate("artist_streams" = sum(streams)) %>%
  ungroup() %>%
  #relocate(songs_per_artist, .before = released_year )
  
  # Creamos las variables "rango_bpm" ; "tempo"
  mutate(rango_bpm = cut(bpm, breaks = breaks_bpm, include.lowest = TRUE),
         tempo = factor(case_when(
           between(bpm, 60, 100) ~ "Lenta",
           between(bpm, 101, 120) ~ "Normal",
           between(bpm, 121, 210) ~ "Rápida"
         ))) %>% 
  relocate(rango_bpm, .before = key) %>% 
  relocate(tempo, .after = rango_bpm) %>% 
  
  # Renombramos variables
  dplyr::rename("dance%" = `danceability_%`,
         "valence%" = `valence_%`,
        "energy%" = `energy_%`,
         "acoustic%" = `acousticness_%`,
         "instrumental%" = `instrumentalness_%`,
         "live%" = `liveness_%`,
         "speech%" = `speechiness_%`,
         artist = `artist(s)_name`) %>% 
  
  
  # Creamos la variable epoca
  mutate(epoca = case_when(
  between(released_year, 1930, 1999) ~ "Epoca_1",
  between(released_year, 2000, 2015) ~ "Epoca_2",
  between(released_year, 2016, 2021) ~ "Epoca_3",
  between(released_year, 2022, 2023) ~ "Epoca_4",
  )) %>% 
  relocate(epoca, .after = released_year) %>% 
  mutate(epoca = ordered(epoca, labels = c("Epoca_1", "Epoca_2", "Epoca_3", "Epoca_4"))) %>% 
  
  
  # Añadimos la variable estación de lanzamiento
  mutate("released_season" = case_when(
    released_month %in% c(12, 1, 2) ~ "winter",
    released_month %in% 3:5 ~ "spring",
    released_month %in% 6:8 ~ "summer",
    released_month %in% 9:11 ~ "autumn",
    NA ~ NA)) %>% 
  
  # Necesario para definir la variable época
  mutate(released_year = as.ordered(released_year)) %>% 

  # Eliminamos ciertas variables
  select(!contains("charts")) %>% 
  
  # Recolocamos las variables
  relocate(streams, .after = artist_count) %>% 
  relocate(released_day, .before = released_year) %>% 
  relocate(released_month, .before = released_year) %>% 
  relocate(artist, .before = track_name) %>%
  relocate(released_season, .before = released_year) %>%
  relocate(artist_streams, .before = released_day) %>%
  relocate(collaboration, .before = streams)

# Orden personalizado de las estaciones del año
orden_estaciones <- c("spring", "summer", "autumn", "winter")

# Cambia el orden de las estaciones del año
spotify2$released_season <- factor(spotify2$released_season,
                                   levels = orden_estaciones)

spotify2 %>% 
  glimpse
```

## Descripción de las variables

Realicemos una descripción de cada variable:

-   *artist*: variable cualitativa que muestra el nombre del artista (o artistas) de la canción.

```{r head artist name}
head(spotify2$artist,5)
```

-   *track_name*: variable cualitativa que muestra el nombre de la canción. Mostramos las 5 primeras canciones presentes:

```{r head track name}
head(spotify2$track_name,5)
```

-   *artist_count*: variable cualitativa que mide el número de artistas que contribuyen a la canción.

```{r summary artist count}
summary(spotify2$artist_count)
```

-   *collaboration*: variable cualitativa creada por nosotros que divide las canciones en dos grupos dependiendo de si han sido creadas por el propio artista o si es una colaboración de diferentes artistas:

```{r}
head(spotify2$collaboration,5)
```

-   *streams*: variable cuantitativa que representa el número de reproducciones en Spotify

```{r summary streams}
summary(spotify2$streams)
```

-   *artist_streams*: variable cuantitativa creada por nosotros que representa el número de reproducciones totales por artista en Spotify.

```{r}
head(spotify2$artist_streams,5)
```

-   *released_day*: variable cualitativa ordinal que representa el día en el que se lanzó.

```{r summary released day}
summary(spotify2$released_day)
```

-   *released_month*: variable cualitativa ordinal que representa el mes en el que se lanzó.

```{r summary released month}
summary(spotify2$released_month)
```

-   *released_season*: variable cualitativa creada por nosotros que representa le estación del año en la que se lanzó la canción:

```{r}
summary(spotify2$released_season)
```

-   *released_year*: variable cualitativa ordinal que representa el año en el que se lanzó.

```{r summary released year}
summary(spotify2$released_year)
```

-   *epoca*: variable cualitativa que muestra la época en que pertenece la canción según nuestros grupos, que son: época 1, de 1930 a 1999; época 2, de 2000 a 2015; época 3, de 2016 a 2021; y época 4, 2022 y 2023.

```{r summary epoca, warning = FALSE}
summary(spotify2$epoca)
```

-   *in_spotify_playlists*: variable cuantitativa que mide el número de listas de reproducción de Spotify en las que está incluida la canción.

```{r summary spotify playlists}
summary(spotify2$in_spotify_playlists)
```

-   *in_apple_playlists*: variable cuantitativa que mide el número de listas de reproducción de Apple Music en las que está incluida la canción.

```{r summary apple playlists}
summary(spotify2$in_apple_playlists)
```

-   *in_deezer_playlists*: variable cuantitativa que mide el número de listas de reproducción de Deezer en las que está incluida la canción.

```{r summary deezer playlists}
summary(spotify2$in_deezer_playlists)
```

-   *bpm*: variable cuantitativa que mide el número de beats por minuto (bpm) de la canción.

```{r summary bpm}
summary(spotify2$bpm)
```

-   *rango_bpm*: variable cualitativa que muestra en qué rango pertenece el bpm de la canción según nuestros grupos.

```{r summary rango bpm}
summary(spotify2$rango_bpm)
```

-   *key*: variable cualitativa que expresa la tonalidad de la canción.

```{r summary key}
summary(spotify2$key)
```

-   *mode*: variable cualitativa que representa la escala de la canción

```{r summary mode}
summary(spotify2$mode)
```

-   *dance%*: variable cuantitativa que indica en porcentaje qué tan adecuada es la canción para bailar.

```{r summary danceability}
summary(spotify2$"dance%")
```

-   *valence%*: variable cuantitativa que indica en porcentaje la positividad del contenido musical de la canción.

```{r summary valence}
summary(spotify2$"valence%")
```

-   *energy%*: variable cuantitativa que indica en porcentaje el nivel de energía percibido de la canción.

```{r summary energy}
summary(spotify2$"energy%")
```

-   *acoustic%*: variable cuantitativa que indica en porcentaje la cantidad de sonido acústico en la canción.

```{r summary acousticness}
summary(spotify2$"acoustic%")
```

-   *instrumental%*: variable cuantitativa que indica en porcentaje la cantidad de contenido instrumental en la canción.

```{r summary instrumentalness}
summary(spotify2$"instrumental%")
```

-   *live%*: variable cuantitativa que indica en porcentaje la presencia de elementos de actuación en directo.

```{r summary liveness}
summary(spotify2$"live%")
```

-   *speech%*: variable cuantitativa que indica en porcentaje la cantidad de palabras habladas en la canción.

```{r summary speechiness}
summary(spotify2$"speech%")
```

Una vez vistos el pequeño resumen del dataset y las descripciones de cada variable, procedamos a estudiar las secciones consideradas, no sin antes responder a dos preguntas de posible interés para el lector, que son determinar las 10 canciones y los 10 artistas más escuchados en Spotify 2023:

```{r gráfico top 10 canciones, fig.width = 12, fig.height = 6, warning = FALSE}
a10 <- spotify2 %>%
  arrange(desc(streams)) %>%
  slice_head( n = 10 )

colores_degradados2 <- rainbow(length(unique(a10$artist)),start = .7, end = 1)
a10  %>%
  ggplot() + 
  geom_col(aes(x = reorder(track_name, desc(streams)) , y = streams, fill = a10$artist)) +
  scale_fill_manual(values = colores_degradados2, breaks = a10$artist) +
  
  labs(title = "Top 10 canciones más reproducidas en Spotify",x = "Canción", y = "Reproducciones ") +
  
  guides(fill = guide_legend(title = "Artista")) +
  
  theme_bw() + 
  
  theme(axis.text = element_text(face = "bold", angle = 25, vjust = 0.5, hjust = 1),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold")) +
  theme(plot.title=element_text(size=20, face='bold', color='purple'))



```

```{r gráfico top 10 cantantes, fig.width = 12, fig.height = 6}

b10 <- spotify2 %>%
  arrange(desc(artist_streams)) %>%
  distinct(artist, .keep_all = TRUE) %>% #elimina las filas duplicadas en funcion de la columna artist_name
  slice_head( n = 10 )

colores_degradados3 <- colorRampPalette(c("cyan3", "yellow2"))(length(unique(b10$track_name)))




b10  %>%
  
  ggplot() + 
  geom_col(aes(x = reorder(artist, desc(artist_streams)) , y = artist_streams, fill = artist)) +

  scale_fill_manual(values = colores_degradados3,breaks = b10$artist) +
  
  labs(title = "Top 10 artistas con más reproducciones en Spotify",x = "Artista", y = "Reproducciones ") +
  theme_bw() + 
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold")) +
  theme(plot.title=element_text(size=20, face='bold', color='cyan3'), plot.subtitle = element_text(size=20, face='bold'))



```

# Vector de medias y matriz de correlación.

Primero de todo, mostremos el vector de medias y la matriz de correlaciones de las variables cuantitativas.

```{r vector medias}
v_medias <- spotify2 %>% 
  summarise(across(where(is.numeric), ~mean(., na.rm = TRUE)))

variables = spotify2 %>% 
  select(where(is.numeric)) %>% 
  colnames()

v_medias = as.vector(v_medias)

cbind(medias = v_medias)

```

```{r correlacion entre variables cuantitativas, fig.width = 20, fig.height = 10}
spotify2 %>%
  select(where(is.numeric)) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(., cex = 1, xsrt = 30, cex.axis = 1, main = "Correlación Entre Variables Cuantitativas")


```

Podemos observar en la matriz que tenemos variables que están correlacionadas, sobretodo positivamente. El estudio de estas correlaciones se verá con más detalle en los siguientes apartados.

## 1. Características comunes de las canciones.

Para resolver la cuestión de qué características comunes tienen nuestro conjunto de canciones más exitosas en 2023 vamos a realizar un gráfico de correlaciones entre estas junto con su número de reproducciones y así ver qué variables estan relacionadas, si es que existe relación entre alguna de ellas:

```{r correlación características, fig.width = 10, fig.height = 6}
spotify2 %>%
  select(streams,bpm, contains("%")) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(., cex = 0.5, xsrt = 30, main = "Matriz de correlación reducida a las características")
```

Como podemos observar la mayor parte de pares de variables no presentan correlación, además de que las distintas características de una canción apenas tienen correlación con el número de reproducciones de ésta, por lo que no podemos ver una relación directa entre algunas características numéricas de las canciones con el número de reproducciones.

Aún así, veamos los siguientes gráficos de los pares de variables más correlacionados `energy_%`\~`acousticness_%`, `danceability_%`\~`valence_%` y `valence_%`\~`energy_%` según el modo en una matriz de gráficos de dispersión.

```{r matriz dispersion, fig.height=20, fig.width=20, warning = FALSE, message = FALSE}

matriz_dispersion <- spotify2 %>% 
  select(19:23) %>% 
  ggpairs(aes(color = spotify2$mode, alpha = 0.75), binwidth = 30, 
          title = "Matriz de dispersión (Original)") +
  theme(plot.title=element_text(size=20, face='bold', color='black'), plot.subtitle = element_text(size=20, face='bold'))

matriz_dispersion

```

Aquí vemos una correlación positiva entre las variables `dance%` y `valence%` , así como entre `energy%` y `valence%` . También vemos una correlación negativa entre `energy%` y `acoustic%`, que es el par de variables con la correlación más fuerte. También, podemos observar que si nos restringimos a las canciones en modo mayor, presentan una correlación más fuerte.

A continuación vamos a realizar unos contrastes de correlación para determinar que efectivamente, como hemos visto en el gráfico anterior, estos pares de variables tienen correlaciones positivas o negativas. Empecemos realizando el siguiente contraste donde las variables X e Y son `dance%` y `valence%`; `energy%` y `valence%`; `energy%` y `acoustic%` respectivamente:

X e Y son `dance%` y `valence%` respectivamente:
$$\begin{cases}
H_{0}: &  \rho_{X,Y}=0\\
H_{1}: & \rho_{X,Y}>0
\end{cases}$$

```{r}

cor.test(spotify2$`dance%`, spotify2$`valence%` , alternative="greater")

```

X e Y son `energy%` y `valence%` respectivamente: $$\begin{cases}
H_{0}: &  \rho_{X,Y}=0\\
H_{1}: & \rho_{X,Y}>0
\end{cases}$$

```{r}

cor.test(spotify2$`energy%`, spotify2$`valence%`, alternative="greater")

```

X e Y son `energy%` y `acoustic%` respectivamente: $$\begin{cases}
H_{0}: &  \rho_{X,Y}=0\\
H_{1}: & \rho_{X,Y}<0
\end{cases}$$

```{r}

cor.test(spotify2$`energy%`, spotify2$`acoustic%`, alternative="less")

```

El p-valor $< 0.00000000000000022$ nos da evidencia estadísticamente significativa de que rechazamos las hipotesis nulas y aceptamos las alternativas, así como los intervalos de confianza, que ninguno contiene el $0$ y en los tres casos, nuestras correlaciones muestrales pertenecen a los intervalos.

Así, vemos que cuanto más buena para bailar es una canción, viene asociado con más positividad; también, cuanto más enérgica, viene asociado con más positividad; y cuanto más enérgica, viene asociado con menos nivel acustico.

Ahora, veamos qué pasa con estas correlaciones si nos restringimos aun más a las 100 canciones más escuchadas.

### Top 100 canciones y sus caracteristicas:

Vamos a crear el subtible con las 100 canciones más reproducidas en Spotify basándonos en la variable *streams*.

```{r top 100 canciones, warning=FALSE}
top100canciones <- spotify2 %>% 
  slice_max(streams, n = 100)

top100canciones %>% 
  glimpse
```

Una vez obtenido el subtibble, mostremos la matriz de correlación del subtibble junto con la matriz de correlación original.

```{r matriz correlacion top100, fig.width=10, fig.height=6}
spotify2 %>%
  select(streams,bpm, 20:26) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(., cex = 0.5, main = "Matriz de correlación (Original)")

top100canciones %>%
  select(streams,bpm, 20:26) %>%
  na.omit(.) %>% 
  cor(.) %>% 
  corPlot(., cex = 0.5, xsrt = 30, main = "Matriz de correlación (Top 100)")
```

Seguimos sin ver ninguna correlación fuerte de alguna variable con *streams*. Sin embargo, fijémonos que obtenemos correlaciones más fuertes en general. En particular, estas correlaciones son más fuertes en los pares de variables estudiados anteriormente.

Volvamos a relizar la matriz de gráficos de dispersión de las 100 canciones más escuchadas y vamos a compararla con la matriz original.

```{r matriz dispersion top100, fig.height=20, fig.width=20, message = FALSE}
matriz_dispersion_100 <- top100canciones %>% 
  select(19:23) %>% 
  ggpairs(aes(color = top100canciones$mode, alpha = 0.75), binwidth = 30, 
          title = "Matriz de dispersión (Top 100)")+
  theme(plot.title=element_text(size=20, face='bold', color='black'), plot.subtitle = element_text(size=20, face='bold'))
  

par(mfrow = c(1, 2))

matriz_dispersion
matriz_dispersion_100

par(mfrow = c(1, 1))
```

Efectivamente, podemos ver una asociación más fuerte en los pares de variables estudiados.

## 2. Analisis de las reproducciones de la canción según la estación del año.

Realizaremos un boxplot por cada estación del año, añadiendo la media, para visualizar la variable *streams*.

```{r streams segun estacion, fig.height=5, fig.width=8}
colores_clase = c("#83CC3A", "#EDED2A", "#B66F01", "#A0EAF1")

spotify2 %>% 
  drop_na(released_season, streams) %>% 
  group_by(released_season) %>% 
  ggplot() + 
  geom_boxplot(aes(x = released_season, y = streams, color = released_season)) +
  stat_summary(aes(x = released_season, y = streams),
               fun = mean, geom = "point", shape = 19, size = 1, color = "black") +
  labs(title = "Boxplot streams según la estación", x = "Estación de lanzamiento", y = "Reproducciones en Spotify", 
       color = "Estaciones del año") +
  theme_bw() + 
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold")) + 
  scale_color_manual(values = colores_clase) +
  theme(plot.title=element_text(size=20, face='bold', color="#83CC3A"))


```

Podemos ver que las cajas mantienen rangos muy similares y que las canciones exitosas son valores atípicos. Una posible interpretación de este gráfico es que las canciones exitosas no dependen únicamente de la estación del año en que se lancen.

Sin embargo, podemos ir un paso más allá y mirar qué pasa si agrupamos las canciones según el mes de lanzamiento.

```{r streams segun mes, fig.height=5, fig.width=10}
colores_clase = c(rep("#A0EAF1", 2), rep("#83CC3A", 3), rep("#EDED2A", 3),
                  rep("#B66F01", 3), "#A0EAF1")

meses <- c("January", "February", "March", "April", "May", "June", "July", "August",
           "September", "October", "November", "December")

spotify2 %>% 
  drop_na(released_season, streams) %>% 
  group_by(released_season) %>% 
  ggplot() + 
  geom_boxplot(aes(x = factor(released_month, levels = 1:12, labels = meses),
                   y = streams, color = released_month)) +
  stat_summary(aes(x = factor(released_month, levels = 1:12, labels = meses), 
                   y = streams),
               fun = mean, geom = "point", shape = 19, size = 1, color = "black") +
  labs(title = "Streams según mes del año", x = "Mes de lanzamiento", y = "Reproducciones en Spotify", 
       color = "Meses del año") +
  theme_bw() + 
  theme(axis.text = element_text(face = "bold"),
        axis.title = element_text(face = "bold"),
        legend.title = element_text(size = 10, face = "bold"),
        legend.position = "none") + 
  scale_color_manual(values = colores_clase) +
  theme(plot.title=element_text(size=20, face='bold', color="#83CC3A"))
```

En este caso, podemos ver en los meses enero y septiembre que el extremo superior del rango intercuartílico es mayor a los otros meses así como el extremo superior del bigote. Así que podría ser favorable para tener una canción exitosa lanzarla en uno de estos dos meses.

## 3. Top 5 artistas con más canciones en el dataset y comparación de las propiedades de las canciones.

Veamos cuáles son los 5 artistas con más canciones en el dataset. Hemos considerado solo las canciones donde artist(s)\_count = 1, es decir, no hemos tenido en cuenta las colaboraciones. Así pues, el top 5 es:

```{r top5}

# Dataset Artistas top5 - Num_canciones
top5 = spotify2 %>% 
  group_by(artist) %>% 
  summarise(count = n(), .groups = "drop") %>% 
  arrange(desc(count)) %>% 
  slice_head(n = 5)

top5
```

Ahora para tratar con los datos que nos interesan, definimos otro tibble que solo contenga las canciones de estos artistas. Obtenemos que el número de realizaciones es $111$, como esperábamos.

```{r dataset_top3, warning= FALSE}

# Dataset completo con solo los artistas top 5
spotify_top5 = spotify2 %>% 
  filter(artist %in% c("Taylor Swift", "The Weeknd", "Bad Bunny", "SZA", "Harry Styles")) %>% 
  arrange(artist)
  
spotify_top5 %>% 
  glimpse


# Dataset Artistas top5
spotify_top5_artists = spotify_top5 %>% 
  group_by(artist) %>% 
  summarise()

```

Para comparar las canciones por artista, lo haremos en dos partes: primero las consideraremos a nivel teórico, es decir, se describirán los datos a partir de la tonalidad, escala utilizada y su bpm ; posteriormente se analizarán las canciones según sus propiedades a partir de las variables "bailabilidad", "valencia", "energía", "acústico", "instrumental", "vivacidad", "habla".

## Key

Mostramos las frecuencias de cada tonalidad (sin considerar el modo) por cada artista.

```{r, frecuencias key(top5), fig.width = 10, warning = FALSE}

colores_degradados <- colorRampPalette(c("cyan3", "purple"))(length(unique(spotify_top5$key)))

spotify_top5 %>% 
  drop_na(key) %>% 
  ggplot() +
  geom_bar(aes(x = key, fill = key), alpha = 0.7) +
  facet_grid(.~artist) +
  
  scale_x_discrete(limits = c("C", "C#", "D", "D#", "E", "F", "G", "G#", "A", "A#", "B")) +
  scale_y_discrete(limits = 0:7) +
  
  labs(x= "Tonalidad de la canción", y= "Número de canciones") +
  
  theme_bw() +
  theme(axis.text = element_text(size=6),
        axis.title = element_text(size=10, face = "bold"),
        legend.title = element_text(size=10)) +
  
  guides(fill = guide_legend(title = "Tonalidad")) +
  
  scale_fill_manual(values = colores_degradados) +
  
  labs(title = "Frecuencias según la tonalidad",
       subtitle = "Top 5 artistas") +
  theme(plot.title=element_text(size=20, face='bold', color='blue'), plot.subtitle = element_text(size=20, face='bold'))



```

A partir de estas realizaciones no parece haber alguna distribución común de las canciones según la tonalidad. En cada artista se puede ver como una preferencia de tonalidad: en las canciones de Taylor Swift, presenta mayor número de canciones en las tonalidades "F", "G", "G#", en cambio, las canciones de The Weeknd hay mayor concentración en las tonalidades "A", "A#". Por otro lado, artistas como Harry Styles tiene una concentración más uniforme.

Si nos quedamos con la tonalidad más usada por artista:

```{r, tonalidad dominante por artista}

spotify_top5 %>% 
  drop_na(key) %>% 
  group_by(artist, key) %>% 
  summarise(Frecuencia = n(), .groups = "drop") %>% 
  pivot_wider(names_from = key,
              values_from = Frecuencia)


```

```{r tibble tono_mas_usado(top5)}

spotify_top5_key = cbind(spotify_top5_artists, Tono_mas_usado = c("C# - F", "E", "C# - F - G", "G", "A"))

spotify_top5_key
```

Vemos que todos los artistas tienen una tonalidad principal distinta, excepto SZA ya que el número de canciones por tonalidad está más balanceado.

## Key y mode

Veamos ahora cuántas canciones hay en los grupos key \~ mode por artista:

```{r grafica(key,mode,artist)2,fig.width = 10, warning = FALSE}

spotify_top5 %>% 
  drop_na(key, mode) %>% 
  ggplot() +
  geom_bar(aes(x = key, fill = key), alpha = 0.7) +
  facet_grid(mode~artist) +
  
  scale_x_discrete(limits = c("C", "C#", "D", "D#", "E", "F", "G", "G#", "A", "A#", "B")) +
  scale_y_discrete(limits = 0:7) +
  
  labs(x= "Tonalidad de la canción", y= "Número de canciones") +
  
  theme_bw() +
  theme(axis.text = element_text(size=8),
        axis.title = element_text(size=10, face = "bold"),
        legend.title = element_text(size=10)) +
  
  guides(fill = guide_legend(title = "Tonalidad")) +
  
  scale_fill_manual(values = colores_degradados) +
  labs(title = "Frecuencias según tonalidad y modo",
       subtitle = "Top 5 artistas") +
  theme(plot.title=element_text(size=20, face='bold', color='blue'), plot.subtitle = element_text(size=20, face='bold'))
  

```

A partir de esta gráfica se puede observar que en general la escala mayor predomina en todos los artistas, comprobémoslo:

```{r, Mayor_menor}

# Función para saber la diferencia Major - Minor
f = function(x){
  i = 1
  j = 1
  v = c(0)
  
  while(i < length(x)) {
    
    v[j] = x[i] - x[i+1]
    i = i+2
    j = j+1
  }
  return(v)
}

#Dataset con Artista ~ Mode - Frecuencia
Frecuencia = spotify_top5 %>% 
  group_by(artist, mode) %>% 
  summarise(Frecuencia = n(), .groups = "drop") %>% 
  pull(Frecuencia)



# Dataset con Artistas top5 - Frecuencia - Modo_dominante
major_minor = cbind(spotify_top5_artists, Major_Minor = f(Frecuencia)) %>% 
  mutate(Modo_dominante = case_when(
      Major_Minor > 0 ~ "Major",
      Major_Minor < 0 ~ "Minor",
      Major_Minor == 0 ~ "Ninguna"), .keep = "all")


major_minor

```

Vemos que el único artista que ha utilizado más la escala menor es "The Weeknd". Por otro lado, destaca que ninguna canción de los artistas presenta la tonalidad $C$ (Do) en modo Mayor, que es la escala más conocida, aunque también básica en cuanto a novedad.

## Streams

Una vez visto como se relacionan estas variables respecto estos artistas, mostremos las reproducciones que tuvieron cada canción con el siguiente gráfico:

```{r, streams por key, fig.width = 10}
spotify_top5 %>% 
  drop_na(key, streams) %>% 
  ggplot(aes(x = key, y = streams, color = mode)) +
  geom_point() +
  facet_grid(.~artist) +
  
  labs(x= "Tonalidad de la canción", y= "Streams") +
  guides(fill = guide_legend(title = "Modo")) +
  
  theme_bw() +
  labs(title = "Streams según la tonalidad",
       subtitle = "Top 5 artistas") +
        
    theme(axis.text = element_text(size=8),
        axis.title = element_text(size=12, face = "bold"),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15)) +
  theme(plot.title=element_text(size=20, face='bold', color='blue'), plot.subtitle = element_text(size=20, face='bold'))
  
```

Pordemos observar que todos los puntos estan concentrados en el rango $[0, 1.5*10^9]$ reproducciones, excepto una canción de The Weeknd que supera las $3*10^9$ reproducciones. Veamos la media de reproducciones por artista:

```{r media streams(artist)}

spotify_top5 %>% 
  group_by(artist) %>% 
  summarise(Media_streams = mean(streams))
  
```

Tenemos que Harry Styles y The Weeknd tienen la media de reproducciones (recordemos que se considera solo en Spotify) más alta. Hay que tener en cuenta que de esta lista la muestra de cada artista es distinta, por ejemplo solo hay 17 canciones de Harry Styles y 34 canciones de Taylor Swift. Si tenemos en cuenta el modo, las medias son las siguientes:

```{r, media streams(mode)}

spotify_top5 %>% 
  group_by(artist, mode) %>% 
  summarise(Media_streams_modo = mean(streams), .groups = "drop")

```

En los artistas Bad Bunny, SZA y Taylor Swift la diferencia es relativamente baja, en cambio en los artistas Harry Styles y The Weeknd, la diferencia resalta habiendo diferencias de casi 300 millones de reproducciones. Por último, si hacemos las medias respecto la tonalidad:

```{r, media streams(key-table)}
tabla_media_key = spotify_top5 %>% 
  drop_na(key) %>% 
  group_by(artist, key) %>% 
  summarise(Media_streams_key = mean(streams), .groups = "drop") %>% 
  pivot_wider(names_from = key,
              values_from = Media_streams_key)

tabla_media_key
```

```{r, media streams(key-tibble)}
tonalidad_table = c("C#", "F", "G", "G#", "A", "A#", "B", "D", "D#", "E")


vec_max = c(0)
vec_max_key = c("0")
for(k in 1:5){
  vec_max[k] = max(tabla_media_key[k,-1], na.rm = TRUE)
  vec_max_key[k] = tonalidad_table[which.max(tabla_media_key[k,-1])]
  
}

cbind(spotify_top5_artists, Max = vec_max, Max_key = vec_max_key)


```

Tenemos que, exceptuando al artista The Weeknd, las tonalidades con media de reproducciones más alta son notas consecutivas ("G", "G#", "A"), que puede ser una coincidencia o bien una preferencia de los oyentes: cada nota tiene asociada una frecuencia, por ejemplo la nota La4 (en inglés"A4") tiene la frecuencia de $440$Hz, entonces estas frecuencias asociadas al reposo de la canción (la tonalidad se podría describir como una estabilidad/equilibrio en la melodía) pueden ser más agradables a nivel auditivo.


## bpm

Para estudiar el bpm de las canciones crearemos una nueva variable, "rango_bpm" donde dividiremos las canciones en tres grupos: "lenta", "normal" o "rápida" según si el bpm está entre $60-100$, entre $101-120$ o bien entre $121-210$ respectivamente, donde hemos ajustado estos rangos según los valores que toma la variable bpm en el dataset.

Estudiemos el número de reproducciones de cada artista según el bpm utilizado:

```{r grafico_top5(bpm), fig.width= 10}

spotify_top5 %>% 
  ggplot() +
  geom_point(aes(x = bpm, y = streams, color = artist), show.legend = FALSE) +
  facet_grid(.~ artist) +
  theme_bw() +
  
  labs(x= "bpm", y= "Streams") +
  guides(fill = guide_legend(title = "Artista")) +
  
  theme_bw() +
  theme(axis.text = element_text(size=8),
        axis.title = element_text(size=12, face = "bold")) +
  
  labs(title = "Reproducciones según el bpm por artista",
       subtitle = "Top 5 artistas") +
  theme(plot.title=element_text(size=20, face='bold', color='red'), plot.subtitle = element_text(size=20, face='bold'))


```

Vemos que las canciones se concentran en un bpm entre $90$ y $120$, que tiene sentido ya que los géneros musicales tienen un bpm medio entre esos valores. Debido a la falta de realizaciones no se puede deducir algún comportamiento de la variable "streams" según el bpm de las canciones de estos artistas.

Representaremos los datos a partir de un boxplot por cada artista para ver como se distribuye los cuartiles en función de la variable "streams".

```{r boxplot_bpm(top5), fig.width= 10}

spotify_top5 %>% 
  ggplot() +
  geom_boxplot(aes(x = tempo, y = streams, color = artist), show.legend = FALSE)+
  facet_grid(.~artist) +
  theme_bw()+
  geom_jitter(aes(x = tempo, y = streams, color = artist), alpha = 0.5, 
              show.legend = FALSE, 
              position = position_jitter(width = 0.2, seed = 0)) +
  labs(x = "Tempo", y = "Streams") +
  labs(title = "Reproducciones según el tempo",
       subtitle = "Top 5 artistas") +
  theme(plot.title=element_text(size=20, face='bold', color='red'), plot.subtitle = element_text(size=20, face='bold'))


```

A partir de estos gráficos no podemos ver si hay la elección del bpm influye en el número de reproducciones, ya que cada tempo se comporta de distinta manera para cada artista, por ejemplo el artista Harry Styles, las canciones con más reproducciones parecen ser aquellas con un ritmo lento, en cambio con el artista The Weeknd, el ritmo rápido presenta un mayor rango en la variable reproducciones y dos valores atípicos muy diferenciados.

Veamos si consideramos aquellas canciones donde la variable "bpm" tiene un valor entre $90$ y $120$:

```{r boxplot_bpm_90_120(top5), fig.width=10}


spotify_top5 %>% 
  filter(between(bpm, 90, 120)) %>% 
  ggplot() +
  geom_boxplot(aes(x = artist, y = streams, color = artist), show.legend = FALSE)+
  theme_bw()+
  geom_jitter(aes(x = artist, y = streams, color = artist), alpha = 0.5, 
              show.legend = FALSE, 
              position = position_jitter(width = 0.2, seed = 0)) +
  labs(x = "Artista", y = "Streams") +
  labs(title = "Reproducciones del top 5 artistas",
       subtitle = "bpm entre 90 y 120") +
  
  theme(plot.title=element_text(size=20, face='bold', color='red'), plot.subtitle = element_text(size=20, face='bold'))


```

Tenemos que si restringimos la variables "bpm" entre los valores $90$ y $120$, la distribución de los puntos se mantienen en el mismo rango de valores independientemente del artista.

## Propiedades de las canciones(top 5)

Para comparar estos datos hemos construido un gráfico radar, donde el mínimo es $0%$ y el máximo $100%$. Los valores considerados en cada variable han sido las medias correspondientes a cada artista.

```{r ggradar_artistas_top5, fig.pos="center", warning = FALSE}


# Consideramos las columnas 'artistas' y las de % ; Agrupamos por artistas y hacemos la media
spotify_top5_perc = spotify_top5 %>% 
  select(artist,contains("%")) %>% 
  group_by(artist) %>% 
  summarise(
    across(contains("%"), ~ mean(., na.rm = T))
  )



# Gráfico radar
ggradar(spotify_top5_perc,
        
        #Tamaño texto
        base.size = 15,
        
        # Límites
        grid.min = 0,
        grid.mid = 50,
        grid.max = 100,
        
        # Valores de los límites
        values.radar = c("0%","50%","100%"),
        
        #Fondo
        background.circle.colour = "white",
        
        # Tamaño texto variables
        axis.label.size = 4,
        
        # Color líneas límites
        gridline.min.colour = "gray60",
        gridline.mid.colour = "gray60",
        gridline.max.colour = "gray60",
        gridline.min.linetype = 1,
        gridline.mid.linetype = 1,
        gridline.max.linetype = 1,
        
        # Las líneas y los puntos del radar
        group.line.width = 1.25,
        group.point.size = 5,
        
        # Leyenda
        legend.title = "Artista",
        legend.position = "right",
        legend.text.size = 10
        )


```

Podemos ver que los valores son sorprendentemente parecidos. De aquí se podría deducir que esa distribución tiene una especie de "equilibrio" en el sentido de que variar alguna variable no ofrecería una canción más agradable al oyente, sino que todo está compensado. La única variable que presenta una mayor descompensación es "acoustic" (Cantidad de sonido acústico), que tiene un rango más alto. De esto podemos decir que los 5 artistas con más canciones dentro de las canciones con más reproducciones, presentan una cantidad muy baja de palabras, de instrumental, actuación y destacan por su bailabilidad y energía.

Por otro lado se puede intuir que cierto aumento de una variable puede hacer tender que ptra disminuya, si vemos el gráfico de correlaciones:

```{r correlacion(top5), warning = FALSE}

spotify_top5 %>%
  select(contains("%")) %>%

  na.omit(.) %>%
  cor(.) %>% 
  
  ggcorrplot(., hc.order = TRUE,
        type = "lower",
        colors = c("blue",
                    "white", "red")) +
  labs(title = "Correlación entre las propiedades",
       subtitle = "Top 5 artistas") +
  
  theme(plot.title=element_text(size=15, face='bold', color='black'), plot.subtitle = element_text(size=15, face='bold'))
  



spotify_top5 %>%
  select(contains("%")) %>%
  na.omit(.) %>% 
  cor(.)

```

Tenemos que la energía es una variable importante: en esta muestra se ha visto que cuanta más energía presenta una canción, menos acústico tiene, cosa que en un principio puede ser intuitivo, pero esto depende de qué aspectos tienes en cuenta al medir el nivel de energía y una mayor postividad en la letra.

Otra variable que destaca es precisamente el acústico: en esta muestra se ha visto que cuanta más acústico presenta la canción, menos bailabilidad, positividad y energía tiene.

Entre las variables que no han mostrado tener influencia son la cantidad de palabras y la presencia de elementos de actuación en directo.

## 4. Estudio de las canciones según la época y características.

Hemos dividido las épocs en los siguientes años: 1930-1999 ; 2000-2015 ; 2016-2021 ; 2022-2023. Los rangos de cada época son tan diferentes porque en el dataset predominan sobre todo las canciones escuchadas en 2022 y 2023, mientras que si nos vamos alejando en el tiempo cada vez hay menos canciones. Aún así sigue habiendo una gran diferencia entre el número de muestras por época

### Key y mode por épocas

Veamos las frecuencias de cada tono y modo por época:

```{r grafico_tonalidad_frecuencia(epocas), fig.width= 10}

spotify2 %>% 
  drop_na(key, mode) %>%
  group_by(epoca, key, mode) %>% 
  summarise(Frecuencias = n(), .groups = "drop") %>% 
  ggplot() +
  geom_point(aes(x = key, y = Frecuencias, color = mode), alpha = 0.6) +
  facet_grid(.~epoca) +
  
  theme_bw() +
  labs(x= "Tonalidad de la canción", y= "Frecuencias") +
  guides(fill = guide_legend(title = "Modo")) +
  
  theme_bw() +
  theme(axis.text = element_text(size=8),
        axis.title = element_text(size=12, face = "bold"),
        legend.title = element_text(size = 15),
        legend.text = element_text(size = 15)) +
  scale_x_discrete(limits = c("C", "C#", "D", "D#", "E", "F", "G", "G#", "A", "A#", "B")) +
  labs(title = "Frecuencias según la tonalidad",
       subtitle = "Épocas") +
  theme(plot.title=element_text(size=20, face='bold', color='blue'), plot.subtitle = element_text(size=20, face='bold'))



```

Debido a la gran diferencia de muestras por cada época, no podemos obtener mucha información de los datos. Un aspecto que podemos ver es que ninguna canción de las más reproducidas en Spotify está en $C$ (Do).

### Playlists

Estudiemos ahora con el número de playlists de cada plataforma, a continuación mostraremos un boxplot por cada época:

```{r boxplot_epocas_spotify, warning=FALSE}

ggboxplot(spotify2, x = "epoca" ,y = "in_spotify_playlists",
          title = "Boxplot del número de listas en Spotify",
          subtitle = "Épocas",
          xlab = "Épocas",
          ylab = "Número de playlists en Spotify",
          size = 0.7,
          add="jitter",
          shape="epoca",
          notch = FALSE,
          color="epoca",
          palette = c("#00AFBB", "#E7B800", "#FC4E07","#BB3099")) +
  scale_x_discrete(label = c("1930-1999", "2000-2015", "2016-2021", "2022-2023")) +
  scale_y_continuous(breaks = c(0, 5000, seq(10000, 50000, by = 10000))) +

  theme(plot.title=element_text(size=15, face='bold', color='green4'), plot.subtitle = element_text(size=15, face='bold'))
  

```

En este gráfico podemos ver algo que en principio puede parecer contraintuitivo: las canciones más antiguas ($1930 - 2015$) están presentes en más playlists hechas por la plataforma Spotify que las canciones más actuales ($2016 - 2023$).

Esto puede deberse a varios factores, algunos podrían ser:

-   "Clásicos": teniendo en cuenta que estas canciones son las más reproducidas en Spotify este año, se pueden entender como "clásicos" musicales, enotnces aunque pase el tiempo las personas reclaman estas canciones.

-   "Polivalencia": debido a la fecha de lanzamiento de las canciones y la popularidad de estas, se podrían etiquetar de muchas formas, por ejemplo: "mix de los 2000", "mix de los 90", "clásicos musicales". En cambio, la música popular actual está centrada principalmente en dos géneros musicales: pop y reggaeton.

-   "Fugacidad": actualmente las canciones pueden llegar a más personas debido a la fácil accesibilidad, esto se refleja en las reproducciones. Ahora bien, aunque las canciones se hagan populares, el tiempo que se mantienen es bastante bajo, ya que cada vez hay más artistas y por lo tanto, son canciones de moda.

De la misma manera, podemos hacer un boxplot con las playlists de Apple Music y Deezer:

```{r boxplot_epocas_apple, warning=FALSE}

ggboxplot(spotify2, x = "epoca" ,y = "in_apple_playlists",
          title = "Boxplot del número de listas en Apple Music",
          subtitle = "Épocas",
          xlab = "Épocas",
          ylab = "Número de playlists en Apple Music",
          size = 0.7,
          add="jitter",
          shape="epoca",
          notch = FALSE,
          color="epoca",
          palette = c("#00AFBB", "#E7B800", "#FC4E07","#BB3099")) +
  scale_x_discrete(label = c("1930-1999", "2000-2015", "2016-2021", "2022-2023")) +
  scale_y_continuous(breaks = c(0, 50, seq(100, 700, by = 100))) +

  theme(plot.title=element_text(size=15, face='bold', color='gray4'), plot.subtitle = element_text(size=15, face='bold'))
  

```

En este caso cada época se mantiene en un mismo rango, de aquí se podría deducir que el número de playlists en Apple Music no depende del año de lanzamiento de la canción. Lo más destacable es la época $2016-2021$ que presenta una mayor cantidad de valores atípicos.

```{r boxplot_epocas_deezer, warning=FALSE}

ggboxplot(spotify2, x = "epoca" ,y = "in_deezer_playlists",
          title = "Boxplot del número de listas en Deezer",
          subtitle = "Épocas",
          xlab = "Épocas",
          ylab = "Número de playlists en Deezer",
          size = 0.7,
          add="jitter",
          shape="epoca",
          notch = FALSE,
          color="epoca",
          palette = c("#00AFBB", "#E7B800", "#FC4E07","#BB3099")) +
  scale_x_discrete(label = c("1930-1999", "2000-2015", "2016-2021", "2022-2023")) +
  scale_y_continuous(breaks = c(0, 500, 1000, 2000, 5000, 10000)) +

  theme(plot.title=element_text(size=15, face='bold', color='orange2'), plot.subtitle = element_text(size=20, face='bold'))
  

```

En la plataforma Deezer, destacan las canciones de los años $2000-2015$, que presentan un mayor rango en cuanto a número de listas. Por otro lado, en las canciones de los años $1930-1999$ y $2016-2021$ contienen valores atípicos, especialmente los años $1930-1999$ donde hay una canción que está en más de $10000$ listas de Deezer.

Estudiemos ahora cuáles son las características de las canciones por épocas. De la misma manera que antes, haremos un gráfico radar donde agruparemos por épocas y en cada variable consideraremos el valor medio correspondiente. Así, obtenemos el siguiente gráfico:

```{r ggradar_epocas, fig.pos="center", warning = FALSE}


# Consideramos las columnas 'artistas' y las de % ; Agrupamos por artistas y hacemos la media
spotify_epoca_perc = spotify2 %>% 
  select(epoca, contains("%")) %>% 
  group_by(epoca) %>% 
  summarise(
    across(contains("%"), ~ mean(., na.rm = T))
  )


# Gráfico radar
ggradar(spotify_epoca_perc,
        
        #Tamaño texto
        base.size = 15,
        
        # Límites
        grid.min = 0,
        grid.mid = 50,
        grid.max = 100,
        
        # Valores de los límites
        values.radar = c("0%","50%","100%"),
        
        #Fondo
        background.circle.colour = "white",
        
        # Tamaño texto variables
        axis.label.size = 4,
        
        # Color líneas límites
        gridline.min.colour = "gray60",
        gridline.mid.colour = "gray60",
        gridline.max.colour = "gray60",
        gridline.min.linetype = 1,
        gridline.mid.linetype = 1,
        gridline.max.linetype = 1,
        
        # Las líneas y los puntos del radar
        group.line.width = 1.25,
        group.point.size = 5,
        
        # Leyenda
        legend.title = "Época",
        legend.position = "right",
        legend.text.size = 10
        )


```

Podemos ver que el gráfico resultante es muy similar al que tuvimos cuando estudiábamos a los 5 artistas con más canciones en el Dataset. Podríamos deducir que lo que vimos anteriormente era un caso particular, es decir, realmente la configuración obtenida por los 5 artistas se debe a la configuración por épocas. Otra deducción podría ser que aunque la forma de expresar música haya cambiado debido a los avances tecnológicos, las canciones siempre han seguido las mismas reglas, proporcionando sus características.

Podemos hacer un gráfico de correlaciones por épocas para ver si son las mismas variables las que han mostrado una tendencia respecto otras:

```{r correlacion(epocas), fig.height = 5}


par(mfrow = c(1,2))

corplot_ep1 = spotify2 %>%
  filter(epoca == "Epoca_1") %>%
  select("dance%", "valence%", "energy%", "acoustic%", "instrumental%", "live%") %>% 
  na.omit() %>% 
  cor() %>% 
  corrplot(title = "Época 1")


corplot_ep2 = spotify2 %>%
  filter(epoca == "Epoca_2") %>%
  select("dance%", "valence%", "energy%", "acoustic%", "instrumental%", "live%") %>%
  na.omit() %>% 
  cor() %>% 
  corrplot(title = "Época 2")

par(mfrow = c(1,1))


par(mfrow = c(1,2))

corplot_ep3 = spotify2 %>%
  filter(epoca == "Epoca_3") %>%
  select("dance%", "valence%", "energy%", "acoustic%", "instrumental%", "live%") %>%
  na.omit() %>% 
  cor() %>% 
  corrplot(title = "Época 3")



corplot_ep4 = spotify2 %>%
  filter(epoca == "Epoca_4") %>%
  select("dance%", "valence%", "energy%", "acoustic%", "instrumental%", "live%") %>%
  na.omit() %>% 
  cor() %>% 
  corrplot(title = "Época 4")


par(mfrow = c(1,1))



```

Efectivamente, en general las relaciones de tendencia son las mismas, donde destacan las relaciones de las variables "dance" \~ "valence" \~ "energy" con una correlación positiva y "acoustic" \~ "energy" con una correlación negativa.

## 5. ¿Son igual de famosas las canciones en distintas plataformas?.

En este a último apartado, lo que queremos es comprobar si este conjunto de datos sobre las canciones más escuchadas en Spotify tendrá relación en otras plataformas de música, es decir, si las canciones más escuchadas en Spotify también lo son en plataformas como Apple music y Deezer.

Para ello vamos a usar la función "ggpairs()" que nos da un estudio muy detallado de las relaciones de las variables de reproducción de las canciones con el número de playlists (listas de reproduccion) en las que la canción está metida en las diferentes plataformas.

También nos ha parecido interesante diferenciar el estudio entre si las canciones son fruto de una colaboración entre diferentes artistas o no.

```{r correlacion por plataformas, fig.width = 15, fig.height = 8, message = FALSE, warning = FALSE}
matriz_dispersionn <- spotify2 %>% 
  select(collaboration, streams, matches("in_\\w*_")) %>% 
  ggpairs(aes(color = spotify2$collaboration, alpha = 0.75))

matriz_dispersionn
```

Como podemos ver, obtenemos los resultados esperados al ver que en cuantas más listas de Spotify aparece una canción, esa canción estará también en más listas de las otras plataformas Apple music y Deezer.

Si hacemos el contraste de correlación donde X e Y son in_spotify_playlists e in_apple_playlists respectivamente:

$$\begin{cases}
H_{0}: &  \rho_{X,Y}=0\\
H_{1}: & \rho_{X,Y}>0
\end{cases}$$

```{r}

cor.test(spotify2$in_spotify_playlists, spotify2$in_apple_playlists , alternative="greater")

```

Efectivamente encontramos un p-valor $<0.00000000000000022$ que es muy pequeño y nos permite rechazar la hipotesis nula de que la correlación es 0 y aceptar la altenrativa de que la correlación es positiva y asegurar, con un 95% de probabilidad, que ésta es superior a $0.6806651$.

## Conclusión

Es muy difícil determinar cuales son los factores que pueden llegar a determinar las canciones más exitosas, no existe una fórmula mágica que puedas seguir para asegurarte que la canción que vas a sacar será muy escuchada. Al haber tantos estilos de música, a pesar de contar con las 1000 canciones más reproducidas de Spotify, ha sido dificil encontrar relaciones importantes entre las características de estas.

Nuestras conclusiones de cada punto de interés estudiado son:

1.  Utilizando la matriz de correlaciones y los gráficos de dispersión, hemos podido observar la asociación entre las variables `energy%`~`acoustic%`, `energy%`~`valence%` y `dance%`~`valence%`, que se hace más fuerte restringiéndonos al top100. Así que podríamos seguir estas asociaciones si queremos que una canción se haga viral.

2.  A priori, alguien puede pensar que las canciones lanzadas en verano pueden tener más exito, pero hemos visto que no es necesario. Por el contrario, las canciones lanzadas en enero y septiembre de nuestro dataset son las que parecen haber tenido más éxito.

3.  A partir del estudio descriptivo, parece ser que la tonalidad no es un factor relevante en el sentido de ser una canción con más reproducciones, como hemos visto, aquellos cantantes con más canciones exitosas no muestran una preferencia clara. En cambio, la modalidad sí que muestra una tendencia a la modalidad "mayor", esto tiene sentido ya que los gráficos muestran que la variable "energy%" toma valores altos de media, y esta modalidad se utiliza para canciones más "alegres".

4.  A partir de la variable épocas hemos podido ver que no parece haber diferencia significativa en cuanto al número de playlists de ninguna plataforma, aunque sí se muestra un rango de valores muy distinto. Por otro lado, el ggradar nos hace ver que las proporciones de las propiedades de las canciones son las mismas, es decir que lo único que cambia de la música parece ser la forma de expresarlo.

5.  Como era de esperar, hemos comprobado que existe una gran relación entre el número de listas de reproducción en las que podemos encontrar las canciones respecto a la plataforma donde las escuchamos, comprobando que si una canción aparece en muchas listas de una plataforma, también aparece en muchas listas en otra plataforma.



## Repositorio de GitHub

Para ver el código del estudio, visite [este repositorio de GitHub.](https://github.com/AngelAlamo/Trabajo_AD)


